2. Habilidades que Vas a Necesitar:

    Programación estructurada en C o C++ (el lenguaje clásico de los valientes).

    Backtracking y BFS (porque no todo en la vida se resuelve con fuerza bruta).

    Diseño algorítmico para generar estructuras lógicas sin callejones sin salida.

    Visualización creativa con ASCII o emojis (¡sí, programar también puede ser bonito!).

    Optimización de recursos y tiempos de ejecución (porque hasta los laberintos tienen deadlines).



3. Requisitos Obligatorios (Tu Mapa de Supervivencia)

    Generación del Laberinto:

    El laberinto debe ser generado de forma aleatoria en cada ejecución.

    Debe tener una entrada (esquina superior izquierda) y una salida (esquina inferior derecha), siempre conectadas.

    Asegúrate de que haya al menos un camino válido entre ambos extremos.

    Resolución Automática del Laberinto:

    Implementa un algoritmo que resuelva automáticamente el laberinto.

    Puedes usar Backtracking, BFS o cualquier enfoque lógico que te lleve al éxito.

    
Tamaño Configurable:

    El laberinto debe comenzar con un tamaño fijo (por ejemplo, 10x10).

    Luego, modifícalo para que su tamaño se defina con parámetros externos, sin tocar el código fuente.


Visualización Clara:

    Representa el laberinto en consola usando caracteres ASCII o emojis.

        Muros: #

        Caminos: *

        Entrada y salida marcadas claramente.

    La visualización debe permitir ver el recorrido resuelto.

    Organización & Optimización:

    Separa el programa en partes claras:

        Generación del laberinto

        Visualización

        Resolución

    Toma mediciones de tiempo de ejecución para laberintos de distintos tamaños.

    Usa estructuras de datos eficientes para velocidad y legibilidad.

